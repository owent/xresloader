package org.xresloader.core.data.dst;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.*;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataContainer;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.engine.IdentifyEngine;
import org.xresloader.core.scheme.SchemeConf;

import java.io.*;
import java.nio.charset.Charset;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Created by owentou on 2019/04/08.
 */
public abstract class DataDstUEBase extends DataDstJava {
    static private Pattern fileToClassMatcher = Pattern.compile("[" + Pattern.quote(".-()_") + "\\s]");
    static private String codeFileCommonPrefix = String.join("\r\n", "/**",
            " * This file is generated by xresloader %s, please don't edit it.",
            " * You can find more information about this xresloader on %s .",
            " * If there is any problem, please find or report issues on %s .", " */", "");
    static private String codeHeaderPrefixGuard = String.join("\r\n", "#pragma once", "");
    static private String codeHeaderPrefix1 = String.join("\r\n", "", "#include \"CoreMinimal.h\"",
            "#include \"UObject/ConstructorHelpers.h\"", "#include \"Engine/DataTable.h\"", "");
    static private String codeHeaderIncludeGenerated = "#include \"%s.generated.h\"";
    static private String codeHeaderPrefix2 = String.join("\r\n", "", "", "", "USTRUCT(BlueprintType)", "");
    static private String codeHeaderClassName = "struct %s : public FTableRowBase";
    static private String codeHeaderPrefix3 = String.join("\r\n", "", "{", "    GENERATED_USTRUCT_BODY()", "",
            "    // Start of fields");
    static private String codeHeaderSuffix = "\r\n};";
    static private String codeSourceInclude = "#include \"%s.h\"\r\n";
    static private String ueImportFile = "UnreaImportSettings.json";
    private Charset encodingCache = null;
    private String headerFieldUProperty = null;
    private String headerFieldUFunction = null;

    public enum NAME_TYPE {
        LONG, STRING, DOUBLE
    }

    public class UEDataRowRule {
        public String helper = null;
        public String description = null;
        public NAME_TYPE nameType = NAME_TYPE.LONG;
        public ArrayList<DataDstWriterNodeWrapper> keyFields = null;
        public ArrayList<DataDstWriterNodeWrapper> valueFields = null;
    }

    @Override
    public boolean init() {
        encodingCache = null;
        headerFieldUProperty = null;
        return true;
    }

    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue";
    }

    static public class UECodeInfo {
        public String header = null;
        public String source = null;
        public String outputFile = null;
        public String outputDir = null;
        public String headerDir = null;
        public String sourceDir = null;
        public String includeDir = null;
        public String packageName = null;
        public String clazzName = null;
        public String baseName = null;
        public String category = null;
        public String destinationPath = null;

        public boolean hasGeneratedCode = false;
        public HashMap<String, UECodeInfo> dependencies = null;
        public DataDstWriterNodeWrapper writerNodeWrapper = null;

        UECodeInfo makeDependence(DataDstWriterNodeWrapper writerNodeWrapper) {
            // 这里必须和build_data一样
            String originClazzName = getUETypeName(writerNodeWrapper.getTypeDescriptor());
            if (dependencies != null && dependencies.containsKey(originClazzName)) {
                return dependencies.get(originClazzName);
            }

            UECodeInfo ret = getCodeCache(originClazzName);
            if (ret != null) {
                if (null == dependencies) {
                    dependencies = new HashMap<String, UECodeInfo>();
                }
                dependencies.put(originClazzName, ret);

                ret.writerNodeWrapper = writerNodeWrapper;
                return ret;
            }

            ret = new UECodeInfo();
            ret.writerNodeWrapper = writerNodeWrapper;
            ret.outputFile = this.outputFile;
            ret.outputDir = this.outputDir;
            ret.headerDir = this.headerDir;
            ret.sourceDir = this.sourceDir;
            ret.includeDir = this.includeDir;
            ret.category = this.category;
            ret.destinationPath = this.destinationPath;
            ret.packageName = packageName;

            ret.initClazzName(originClazzName);

            if (null == dependencies) {
                dependencies = new HashMap<String, UECodeInfo>();
            }
            dependencies.put(originClazzName, ret);

            setCodeCache(originClazzName, ret);
            return ret;
        }

        void initClazzName(String originClazzName) {
            this.clazzName = originClazzName;
            if (!originClazzName.isEmpty() && originClazzName.charAt(0) == 'F') {
                this.baseName = originClazzName.substring(1);
            } else {
                this.baseName = originClazzName;
            }
            this.header = this.headerDir + File.separator + this.baseName + ".h";
            this.source = this.sourceDir + File.separator + this.baseName + ".cpp";
        }
    }

    static private HashMap<String, UECodeInfo> globalCodeCache = new HashMap<String, UECodeInfo>();
    static private HashSet<String> globalCodeWrittenCache = new HashSet<String>();

    static UECodeInfo getCodeCache(String clazzName) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        return globalCodeCache.getOrDefault(clazzName, null);
    }

    static void setCodeCache(String clazzName, UECodeInfo code) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        globalCodeCache.put(clazzName, code);
    }

    static public class OneofDataObject {
        public DataDstFieldDescriptor field;
        public Object value;

        public OneofDataObject(DataDstFieldDescriptor f, Object v) {
            this.field = f;
            this.value = v;
        }
    }

    static public class DataDstWriterNodeWrapper implements Comparable<DataDstWriterNodeWrapper> {
        private String varName = null;
        private boolean isGenerated = false;
        private DataDstTypeDescriptor referTypeDescriptor = null;
        private DataDstFieldDescriptor referFieldDescriptor = null;
        private DataDstOneofDescriptor referOneofDescriptor = null;
        private DataDstWriterNodeWrapper referOneofNode = null;
        private DataDstWriterNode referNode = null;

        // key为原始field name
        private HashMap<String, ArrayList<DataDstWriterNodeWrapper>> children = null;

        public DataDstWriterNodeWrapper(String varName, boolean isGenerated, DataDstWriterNode referNode) {
            this.varName = varName;
            this.isGenerated = isGenerated;

            this.referNode = referNode;
            if (this.referNode != null) {
                this.referFieldDescriptor = this.referNode.getFieldDescriptor();
                this.referOneofDescriptor = this.referNode.getOneofDescriptor();
                this.referTypeDescriptor = this.referNode.getTypeDescriptor();
            }
        }

        public String getVarName() {
            return varName;
        }

        public boolean isGenerated() {
            return this.isGenerated;
        }

        public DataDstFieldDescriptor getReferField() {
            if (this.referFieldDescriptor != null) {
                return this.referFieldDescriptor;
            }

            if (this.referNode != null) {
                return this.referNode.getFieldDescriptor();
            }

            return null;
        }

        public void setReferField(DataDstFieldDescriptor field) {
            if (!this.isGenerated || this.referNode != null) {
                return;
            }

            this.referFieldDescriptor = field;
        }

        public DataDstOneofDescriptor getReferOneof() {
            if (this.referOneofDescriptor != null) {
                return this.referOneofDescriptor;
            }

            if (this.referNode != null) {
                return this.referNode.getOneofDescriptor();
            }

            return null;
        }

        public void setReferOneof(DataDstOneofDescriptor oneof) {
            if (!this.isGenerated || this.referNode != null) {
                return;
            }

            this.referOneofDescriptor = oneof;
        }

        public DataDstWriterNode getReferNode() {
            return referNode;
        }

        public DataDstWriterNodeWrapper getReferOneofNode() {
            return this.referOneofNode;
        }

        public void setReferOneofNode(DataDstWriterNodeWrapper n) {
            this.referOneofNode = n;
        }

        public DataDstTypeDescriptor getTypeDescriptor() {
            if (this.referTypeDescriptor != null) {
                return this.referTypeDescriptor;
            }

            if (referNode != null) {
                return referNode.getTypeDescriptor();
            }

            if (this.referFieldDescriptor != null) {
                return this.referFieldDescriptor.getTypeDescriptor();
            }

            return null;
        }

        void setTypeDescriptor(DataDstTypeDescriptor t) {
            // 如果不是生成的，或有绑定数据源则不能设置关联field
            if (!this.isGenerated || null != this.referNode) {
                return;
            }

            this.referTypeDescriptor = t;
        }

        public HashMap<String, ArrayList<DataDstWriterNodeWrapper>> getChildren() {
            return children;
        }

        public boolean hasChidlren() {
            return children != null && !children.isEmpty();
        }

        public void addChidlren(ArrayList<DataDstWriterNodeWrapper> children) {
            if (children == null || children.isEmpty()) {
                return;
            }

            if (this.children == null) {
                this.children = new HashMap<>();
            }

            ArrayList<DataDstWriterNodeWrapper> values = this.children
                    .getOrDefault(children.get(0).getVarName(), null);
            if (values == null) {
                this.children.put(children.get(0).getVarName(), values);
            } else {
                for (DataDstWriterNodeWrapper child : children) {
                    values.add(child);
                }
            }
        }

        public void addChidlren(DataDstWriterNodeWrapper child) {
            if (child == null) {
                return;
            }

            if (this.children == null) {
                this.children = new HashMap<>();
            }

            ArrayList<DataDstWriterNodeWrapper> values = this.children.getOrDefault(child.getVarName(), null);
            if (values == null) {
                values = new ArrayList<DataDstWriterNodeWrapper>();
                this.children.put(child.getVarName(), values);
            }

            values.add(child);
        }

        public JAVA_TYPE getJavaType() {
            DataDstTypeDescriptor typeDesc = getTypeDescriptor();
            if (typeDesc == null) {
                return JAVA_TYPE.STRING;
            }

            return typeDesc.getType();
        }

        static private DataDstMessageExt emptyMsgExt = new DataDstMessageExt();

        public DataDstMessageExt getMessageExtension() {
            DataDstTypeDescriptor rawDesc = getTypeDescriptor();
            if (rawDesc == null) {
                return emptyMsgExt;
            }

            return rawDesc.mutableExtension();
        }

        static private DataDstFieldExt emptyFieldExt = new DataDstFieldExt();

        public DataDstFieldExt getFieldExtension() {
            DataDstFieldDescriptor field = getReferField();
            if (field == null) {
                return emptyFieldExt;
            }

            return field.mutableExtension();
        }

        @Override
        public int compareTo(DataDstWriterNodeWrapper r) {
            DataDstFieldDescriptor lf = getReferField();
            DataDstFieldDescriptor rf = r.getReferField();
            int lv = lf == null ? 0 : lf.getIndex();
            int rv = rf == null ? 0 : rf.getIndex();

            if (lv != rv) {
                return lv - rv;
            }

            lv = referNode == null ? 0 : referNode.getListIndex();
            rv = r.referNode == null ? 0 : r.referNode.getListIndex();
            if (lv != rv) {
                return lv - rv;
            }

            if (referNode != null && referNode.identify != null) {
                lv = referNode.identify.index;
            } else {
                lv = 0;
            }

            if (r.referNode != null && r.referNode.identify != null) {
                rv = r.referNode.identify.index;
            } else {
                rv = 0;
            }

            if (lv != rv) {
                return lv - rv;
            }

            return getVarName().compareTo(r.getVarName());
        }

        public ArrayList<DataDstWriterNodeWrapper> getMapKeyField() {
            if (DataDstWriterNode.SPECIAL_MESSAGE_TYPE.MAP != getTypeDescriptor().getSpecialMessageType()) {
                return null;
            }

            for (HashMap.Entry<String, ArrayList<DataDstWriterNodeWrapper>> d : children.entrySet()) {
                if (d.getValue().isEmpty()) {
                    continue;
                }

                if (d.getKey().equalsIgnoreCase("key")) {
                    return d.getValue();
                }
            }

            return null;
        }

        public ArrayList<DataDstWriterNodeWrapper> getMapValueField() {
            if (DataDstWriterNode.SPECIAL_MESSAGE_TYPE.MAP != getTypeDescriptor().getSpecialMessageType()) {
                return null;
            }

            for (HashMap.Entry<String, ArrayList<DataDstWriterNodeWrapper>> d : children.entrySet()) {
                if (d.getValue().isEmpty()) {
                    continue;
                }

                if (d.getKey().equalsIgnoreCase("value")) {
                    return d.getValue();
                }
            }

            return null;
        }
    }

    static public String[] getIdentSegments(String in) {
        String[] segs = fileToClassMatcher.split(in);
        if (SchemeConf.getInstance().getUEOptions().enableCaseConvert) {
            for (int i = 0; i < segs.length; ++i) {
                if (!segs[i].isEmpty() && Character.isLowerCase(segs[i].charAt(0))) {
                    segs[i] = Character.toUpperCase(segs[i].charAt(0)) + segs[i].substring(1);
                }
            }
            return segs;
        } else {
            return segs;
        }
    }

    static public String getIdentName(String in) {
        if (SchemeConf.getInstance().getUEOptions().enableCaseConvert) {
            return String.join("", getIdentSegments(in));
        } else {
            return String.join("_", getIdentSegments(in));
        }
    }

    public UECodeInfo getCodeInfo(String outputFile, String originClazzName, DataDstWriterNodeWrapper writerNodeWrapper)
            throws IOException {
        File ofd = new File(outputFile);
        if (originClazzName == null || originClazzName.isEmpty()) {
            if (null == writerNodeWrapper || null == writerNodeWrapper.getReferNode()) {
                String fileName = ofd.getName();
                int lastDot = fileName.lastIndexOf('.');
                if (lastDot < 0) {
                    originClazzName = fileName;
                } else {
                    originClazzName = fileName.substring(0, lastDot);
                }
                originClazzName = "F" + getIdentName(originClazzName);
            } else {
                originClazzName = getUETypeName(writerNodeWrapper.getTypeDescriptor());
            }
        }

        UECodeInfo ret = getCodeCache(originClazzName);
        if (ret != null) {
            ret.writerNodeWrapper = writerNodeWrapper;
            return ret;
        }

        ret = new UECodeInfo();
        ret.writerNodeWrapper = writerNodeWrapper;
        ret.outputFile = ofd.getCanonicalFile().getAbsolutePath();
        ret.outputDir = ofd.getParentFile().getCanonicalFile().getAbsolutePath();
        // redirect header directory and source directory
        String codeOutputDir = SchemeConf.getInstance().getUEOptions().codeOutputDir;
        if (codeOutputDir.isEmpty()) {
            codeOutputDir = (new File(ProgramOptions.getInstance().outputDirectory)).getCanonicalFile()
                    .getAbsolutePath();
        }
        if (SchemeConf.getInstance().getUEOptions().category.isEmpty()) {
            ret.category = "DataTable";
        } else {
            ret.category = SchemeConf.getInstance().getUEOptions().category;
        }
        if (!SchemeConf.getInstance().getUEOptions().codeOutputPublicDir.isEmpty()) {
            String pubDir = SchemeConf.getInstance().getUEOptions().codeOutputPublicDir;
            ret.headerDir = codeOutputDir + File.separator + pubDir;
            if (pubDir.charAt(0) == '/' || pubDir.charAt(0) == '\\') {
                pubDir = pubDir.substring(1);
            }
            if (pubDir.substring(0, 7).equalsIgnoreCase("Public/")) {
                ret.includeDir = pubDir.substring(7).replace('\\', '/');
            } else {
                ret.includeDir = pubDir.replace('\\', '/');
            }
            if (!ret.includeDir.isEmpty() && !ret.includeDir.endsWith("/")) {
                ret.includeDir = ret.includeDir + "/";
            }
        } else {
            ret.headerDir = codeOutputDir;
            ret.includeDir = "";
        }
        if (!SchemeConf.getInstance().getUEOptions().codeOutputPrivateDir.isEmpty()) {
            ret.sourceDir = codeOutputDir + File.separator
                    + SchemeConf.getInstance().getUEOptions().codeOutputPrivateDir;
        } else {
            ret.sourceDir = codeOutputDir;
        }

        ret.initClazzName(originClazzName);
        ret.destinationPath = "DataTable";
        if (!SchemeConf.getInstance().getUEOptions().destinationPath.isEmpty()) {
            ret.destinationPath = SchemeConf.getInstance().getUEOptions().destinationPath;
        } else if (ret.includeDir.length() > 1) {
            ret.destinationPath = String.format("%s", ret.includeDir.substring(0, ret.includeDir.length() - 1));
        }

        setCodeCache(originClazzName, ret);
        return ret;
    }

    public void writeImportSettings(UECodeInfo code) {
        File importFile = new File(code.outputDir + File.separator + ueImportFile);
        if (!importFile.getParentFile().exists()) {
            importFile.getParentFile().mkdirs();
        }

        JSONObject importObj;
        JSONArray groupObj;

        if (importFile.exists()) {
            try {
                importObj = new JSONObject(new JSONTokener(new FileInputStream(importFile)));
            } catch (JSONException | FileNotFoundException e) {
                importObj = new JSONObject();
                this.logErrorMessage("Read json from %s failed, %s", importFile.getAbsolutePath(), e.getMessage());
            }
        } else {
            importObj = new JSONObject();
        }

        try {
            if (importObj.has("ImportGroups")) {
                groupObj = importObj.getJSONArray("ImportGroups");
            } else {
                groupObj = new JSONArray();
                importObj.put("ImportGroups", groupObj);
            }

            JSONObject selectedItem = new JSONObject();
            selectedItem.put("GroupName", code.category);

            JSONArray dataFileList = new JSONArray();
            dataFileList.put(code.outputFile);
            selectedItem.put("Filenames", dataFileList);
            selectedItem.put("DestinationPath", code.destinationPath);
            selectedItem.put("bReplaceExisting", "true");
            selectedItem.put("bSkipReadOnly", "true");
            selectedItem.put("FactoryName", "ReimportDataTableFactory");

            JSONObject importSetting = null;
            if (selectedItem.has("ImportSettings")) {
                importSetting = selectedItem.getJSONObject("ImportSettings");
            } else {
                importSetting = new JSONObject();
                selectedItem.put("ImportSettings", importSetting);
            }

            importSetting.put("ImportRowStruct", code.baseName); // 这个得是不带F前缀的名字
            importSetting.put("ImportType", "ECSV_DataTable");

            // remove old items
            for (int i = 0; i < groupObj.length(); ++i) {
                JSONObject oldItem = groupObj.getJSONObject(i);
                if (!oldItem.has("ImportSettings")) {
                    continue;
                }

                if (!oldItem.optString("GroupName").equals(selectedItem.optString("GroupName"))) {
                    continue;
                }

                if (!oldItem.optString("DestinationPath").equals(selectedItem.optString("DestinationPath"))) {
                    continue;
                }

                if (!oldItem.optString("FactoryName").equals(selectedItem.optString("FactoryName"))) {
                    continue;
                }

                JSONObject oldImportSetting = oldItem.getJSONObject("ImportSettings");
                if (!oldImportSetting.optString("ImportType").equals(importSetting.optString("ImportType"))) {
                    continue;
                }

                if (!oldImportSetting.optString("ImportRowStruct").equals(importSetting.optString("ImportRowStruct"))) {
                    continue;
                }

                groupObj.remove(i);
                --i;
            }

            // add new item
            groupObj.put(selectedItem);

            FileOutputStream fos = new FileOutputStream(importFile, false);
            fos.write(dumpString(importObj.toString(4)));
            fos.close();
        } catch (Exception e) {
            this.logErrorMessage("Write json to %s failed, %s", importFile.getAbsolutePath(), e.getMessage());
        }
    }

    private byte[] dumpString(String in) {
        if (null != encodingCache) {
            return in.getBytes(encodingCache);
        }

        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return in.toString().getBytes();

        encodingCache = Charset.forName(encoding);
        return in.getBytes(encodingCache);
    }

    public FileOutputStream createCodeHeaderFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.header);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.header, false);
        fos.write(dumpString(String.format(codeFileCommonPrefix, ProgramOptions.getInstance().getVersion(),
                ProgramOptions.getHomeUrl(), ProgramOptions.getReportUrl())));
        fos.write(dumpString(codeHeaderPrefixGuard));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
        }
        fos.write(dumpString(codeHeaderPrefix1));

        // include all dependicies
        if (code.dependencies != null) {
            for (HashMap.Entry<String, UECodeInfo> varPair : code.dependencies.entrySet()) {
                UECodeInfo depCodeInfo = varPair.getValue();

                // Map类型要输内部依赖的include列表
                if (depCodeInfo.writerNodeWrapper != null && depCodeInfo.writerNodeWrapper.getReferField() != null
                        && depCodeInfo.writerNodeWrapper.getReferField().isMap()) {
                    if (depCodeInfo.dependencies != null) {
                        for (HashMap.Entry<String, UECodeInfo> subVarPair : depCodeInfo.dependencies.entrySet()) {
                            UECodeInfo depSubCodeInfo = subVarPair.getValue();
                            fos.write(dumpString(String.format(codeSourceInclude,
                                    depSubCodeInfo.includeDir + depSubCodeInfo.baseName)));
                        }
                    }
                } else {
                    fos.write(dumpString(
                            String.format(codeSourceInclude, depCodeInfo.includeDir + depCodeInfo.baseName)));
                }
            }
        }

        fos.write(dumpString(String.format(codeHeaderIncludeGenerated, code.baseName)));
        fos.write(dumpString(codeHeaderPrefix2));
        fos.write(dumpString(String.format(codeHeaderClassName, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix3));

        return fos;
    }

    public FileOutputStream createCodeSourceFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.source);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.source, false);
        fos.write(dumpString(String.format(codeFileCommonPrefix, ProgramOptions.getInstance().getVersion(),
                ProgramOptions.getHomeUrl(), ProgramOptions.getReportUrl())));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
            fos.write(dumpString("\r\n"));
        }

        fos.write(dumpString(String.format(codeSourceInclude, code.includeDir + code.baseName)));

        return fos;
    }

    @Override
    public final byte[] build(DataDstImpl compiler) throws ConvException {
        // DataDstJava.DataDstObject data_obj = build_data(compiler);
        Object buildObj = null;
        globalCodeCache.clear();

        try {
            buildObj = buildForUEOnInit();

            build_data(buildObj, compiler);
        } catch (IOException e) {
            throw new ConvException(String.format("build data for %s failed. msg: %s", name(), e.getMessage()));
        }

        return buildForUEOnFinal(buildObj);
    }

    abstract protected Object buildForUEOnInit() throws IOException;

    abstract protected byte[] buildForUEOnFinal(Object buildObj) throws ConvException;

    abstract protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<DataDstWriterNodeWrapper> rowData,
            UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException;

    abstract protected void buildForUEOnPrintRecord(Object buildObj, HashMap<String, Object> rowData,
            UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException;

    private UEDataRowRule rebuildCodeRule(UECodeInfo codeInfo) throws ConvException {
        if (null == codeInfo.writerNodeWrapper) {
            this.logErrorMessage("Can not rebuild code rule without WriterNodeWrapper");
            return null;
        }

        // 生成描述集,CSV必须固定化描述集，可能需要把字段平铺开来。
        DataDstTypeDescriptor msgDesc = codeInfo.writerNodeWrapper.getTypeDescriptor();
        LinkedList<DataDstWriterNodeWrapper> expandedDesc = buildWriterNodeWraper(codeInfo.writerNodeWrapper, msgDesc);

        if (expandedDesc == null || expandedDesc.isEmpty()) {
            return null;
        }

        // ======================================================================================================
        // 递归模式中，第一个为外层Message
        UEDataRowRule rule = buildUEDataRowCodeRule(expandedDesc);
        rule.helper = msgDesc.mutableExtension().mutableUE().helper;
        rule.description = msgDesc.mutableExtension().description;
        // ======================================================================================================

        return rule;
    }

    protected final void build_data(Object buildObj, DataDstImpl compiler) throws ConvException, IOException {
        while (DataSrcImpl.getOurInstance().nextTable()) {
            DataDstTableContent table = buildCurrentTable(compiler);
            if (table == null) {
                continue;
            }

            // 这里规则必须和 makeDependence(table.descriptor)一样
            String originClazzName = getUETypeName(table.descriptor);
            DataDstWriterNodeWrapper rootWriterNodeWrapper = new DataDstWriterNodeWrapper("", true, null);
            rootWriterNodeWrapper.setTypeDescriptor(table.descriptor.getTypeDescriptor());

            UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), originClazzName,
                    rootWriterNodeWrapper);
            UEDataRowRule rule = rebuildCodeRule(codeInfo);

            if (rule == null) {
                continue;
            }

            if (rule.keyFields.isEmpty()) {
                throw new ConvException("DataTable for UE must has a Name field or has field(s) with key_tag");
            }

            // 输出header
            ArrayList<DataDstWriterNodeWrapper> row_data = new ArrayList<DataDstWriterNodeWrapper>();
            row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());
            for (int i = 0; i < rule.keyFields.size(); ++i) {
                row_data.add(rule.keyFields.get(i));
            }
            for (int i = 0; i < rule.valueFields.size(); ++i) {
                // oneof在header上和值一样
                row_data.add(rule.valueFields.get(i));
            }
            buildForUEOnPrintHeader(buildObj, row_data, rule, codeInfo);

            // 输出数据
            for (HashMap<String, Object> row : table.rows) {
                rule.keyFields.forEach((field) -> {
                    fillOneofCache(field, row);
                });
                rule.valueFields.forEach((field) -> {
                    fillOneofCache(field, row);
                });

                // 先用特殊规则导入Name字段,Name字段可能是合成字段
                if (!rule.keyFields.isEmpty()) {
                    Object name_res = pickNameField(buildObj, rule, row);
                    // 忽略未配置Key的行，可能是空行
                    if (name_res == null) {
                        continue;
                    }
                    row.put("Name", name_res);
                }

                buildForUEOnPrintRecord(buildObj, row, rule, codeInfo);

                // TODO hint of datasource?
            }

            // 加载代码
            writeCodeFiles(rule, codeInfo);

            // 写出导出文件
            writeImportSettings(codeInfo);
        }
    }

    private void writeCodeFiles(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException, ConvException {
        if (null == codeInfo || codeInfo.hasGeneratedCode || null == rule) {
            return;
        }
        codeInfo.hasGeneratedCode = true;
        if (codeInfo.dependencies != null) {
            codeInfo.dependencies.clear();
        }

        // 递归写出依赖的数据结构
        if (null != codeInfo.writerNodeWrapper && codeInfo.writerNodeWrapper.hasChidlren()) {
            for (ArrayList<DataDstWriterNodeWrapper> children : codeInfo.writerNodeWrapper
                    .getChildren()
                    .values()) {
                if (children.isEmpty()) {
                    continue;
                }

                // 代码仅提取第一层获取类型即可
                if (children.get(0).getJavaType() != JAVA_TYPE.MESSAGE) {
                    continue;
                }

                UECodeInfo depCodeInfo = codeInfo.makeDependence(children.get(0));
                if (null == depCodeInfo || depCodeInfo.hasGeneratedCode) {
                    continue;
                }

                UEDataRowRule depRule = rebuildCodeRule(depCodeInfo);
                writeCodeFiles(depRule, depCodeInfo);
            }
        }

        // Map 字段仅需要分析依赖，不需要写出代码
        if (codeInfo.writerNodeWrapper != null && codeInfo.writerNodeWrapper.getReferField() != null
                && codeInfo.writerNodeWrapper.getReferField().isMap()) {
            return;
        }
        // 写出加载代码
        writeCodeHeaderFile(rule, codeInfo);
        writeCodeSourceFile(rule, codeInfo);
    }

    static protected DataDstFieldDescriptor getFieldDescriptor(ArrayList<DataDstWriterNodeWrapper> fieldSet) {
        return getFieldDescriptor(fieldSet, 0);
    }

    static protected DataDstFieldDescriptor getFieldDescriptor(ArrayList<DataDstWriterNodeWrapper> fieldSet,
            int index) {
        if (fieldSet == null || index >= fieldSet.size()) {
            return null;
        }

        return fieldSet.get(index).getReferField();
    }

    static protected DataDstOneofDescriptor getOneofDescriptor(ArrayList<DataDstWriterNodeWrapper> fieldSet) {
        return getOneofDescriptor(fieldSet, 0);
    }

    static protected DataDstOneofDescriptor getOneofDescriptor(ArrayList<DataDstWriterNodeWrapper> fieldSet,
            int index) {
        if (fieldSet == null || index >= fieldSet.size()) {
            return null;
        }

        return fieldSet.get(index).getReferOneof();
    }

    @SuppressWarnings("unchecked")
    protected void fillOneofCache(DataDstWriterNodeWrapper field,
            HashMap<?, ?> data) {
        if (field == null) {
            return;
        }

        if (field.getReferOneofNode() == null && (field.getChildren() == null || field.getChildren().isEmpty())) {
            return;
        }

        if (null == data) {
            data = new HashMap<String, Object>();
        }

        Object val = pickJavaFieldValue(data, field);
        if (field.getReferOneofNode() != null) {
            if (val != null) {
                String oneofVarName = field.getReferOneofNode().getVarName();
                ((HashMap<String, Object>) data).put(oneofVarName, field.getVarName());
            }
        }

        // 递归分析子结构
        if (field.getChildren() == null) {
            return;
        }

        if (field.getChildren().isEmpty()) {
            return;
        }

        if (val instanceof List<?>) {
            for (Object element : (List<?>) val) {
                if (!(element instanceof HashMap<?, ?>)) {
                    break;
                }

                for (ArrayList<DataDstWriterNodeWrapper> children : field.getChildren().values()) {
                    if (children.isEmpty()) {
                        continue;
                    }
                    fillOneofCache(children.get(0), (HashMap<?, ?>) element);
                }
            }
        } else if (val instanceof HashMap<?, ?>) {
            for (ArrayList<DataDstWriterNodeWrapper> children : field.getChildren().values()) {
                if (children.isEmpty()) {
                    continue;
                }
                fillOneofCache(children.get(0), (HashMap<?, ?>) val);
            }
        }

    }

    protected Object pickJavaFieldValue(HashMap<?, ?> data, DataDstWriterNodeWrapper fieldWrapper) {
        if (data == null || fieldWrapper == null) {
            return null;
        }

        Object ret = data.getOrDefault(fieldWrapper.getVarName(), null);
        if (ret == null) {
            if (fieldWrapper.getReferField() != null) {
                ret = data.getOrDefault(fieldWrapper.getReferField().getName(), null);
            } else if (fieldWrapper.getReferOneof() != null) {
                ret = data.getOrDefault(fieldWrapper.getReferOneof().getName(), null);
            }
        }

        return ret;
    }

    private Object pickNameField(Object buildObj, UEDataRowRule rule, HashMap<String, Object> data)
            throws ConvException {
        if (rule.keyFields.isEmpty()) {
            return null;
        }

        // 如果是直接采用原始字段则直接返回原始字段数据
        if (1 == rule.keyFields.size() && null != rule.keyFields.get(0).getReferNode()) {
            return pickJavaFieldValue(data, rule.keyFields.get(0));
        }

        switch (rule.nameType) {
            case LONG: {
                long ret = 0;
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                    Object val = pickJavaFieldValue(data, wrapper);
                    if (null == val) {
                        continue;
                    }
                    if (val instanceof Number) {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                * ((Number) val).longValue();
                    } else {
                        try {
                            ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                    * Long.valueOf(val.toString());
                        } catch (NumberFormatException e) {
                            throw new ConvException(
                                    String.format("Try to convert %s to integer failed.%s", val.toString(),
                                            e.getMessage()));
                        }
                    }
                }

                return ret != 0 ? ret : null;
            }
            case DOUBLE: {
                double ret = 0.0;
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                    Object val = pickJavaFieldValue(data, wrapper);
                    if (null == val) {
                        continue;
                    }
                    if (val instanceof Number) {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                * ((Number) val).doubleValue();
                    } else {
                        try {
                            ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                    * Double.valueOf(val.toString());
                        } catch (NumberFormatException e) {
                            throw new ConvException(
                                    String.format("Try to convert %s to number failed.%s", val.toString(),
                                            e.getMessage()));
                        }
                    }
                }

                return ret != 0 ? ret : null;
            }
            case STRING: {
                ArrayList<String> ls = new ArrayList<String>();
                ls.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                    Object val = pickJavaFieldValue(data, wrapper);
                    if (null == val) {
                        continue;
                    }
                    ls.add(val.toString());
                }

                if (ls.isEmpty()) {
                    return null;
                }
                return String.join("", ls);
            }
            default:
                return null;
        }
    }

    protected Object pickValueFieldBaseStandardImpl(DataDstWriterNode desc) throws ConvException {
        if (null == desc || null == desc.identify) {
            return null;
        }

        if (desc.getOneofDescriptor() != null) {
            // 基类中不知道怎么填充子类型
            return null;
        }

        if (desc.getType() == DataDstWriterNode.JAVA_TYPE.MESSAGE) {
            return null;
        }

        switch (desc.getType()) {
            case INT: {
                DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
                if (null != ret && ret.valid) {
                    return ret.value.intValue();
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return Integer.valueOf(0);
                }
                break;
            }

            case LONG: {
                DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
                if (null != ret && ret.valid) {
                    return ret.value.longValue();
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return Long.valueOf(0);
                }
                break;
            }

            case FLOAT: {
                DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
                if (null != ret && ret.valid) {
                    return ret.value.floatValue();
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return Float.valueOf(0);
                }
                break;
            }

            case DOUBLE: {
                DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
                if (null != ret && ret.valid) {
                    return ret.value.doubleValue();
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return Double.valueOf(0);
                }
                break;
            }

            case BOOLEAN: {
                DataContainer<Boolean> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, false);
                if (null != ret && ret.valid) {
                    return ret.value.booleanValue();
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return Boolean.valueOf(false);
                }
                break;
            }

            case STRING: {
                DataContainer<String> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
                if (null != ret && ret.valid) {
                    return ret.value;
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return "";
                }
                break;
            }

            case BYTES: {
                DataContainer<String> res = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
                if (null != res && res.valid) {
                    String encoding = SchemeConf.getInstance().getKey().getEncoding();
                    if (null == encoding || encoding.isEmpty()) {
                        return Base64.getEncoder().encodeToString(res.value.getBytes());
                    } else {
                        return Base64.getEncoder().encodeToString(res.value.getBytes(Charset.forName(encoding)));
                    }
                } else if (ProgramOptions.getInstance().stripListRule == ProgramOptions.ListStripRule.KEEP_ALL) {
                    return "";
                }
                break;
            }

            case MESSAGE: {
                break;
            }
            default:
                break;
        }

        return null;
    }

    private DataDstWriterNodeWrapper mutableOneofWriterNodeWrapper(DataDstWriterNodeWrapper root,
            HashMap<String, DataDstWriterNodeWrapper> cache, DataDstOneofDescriptor oneof) {
        String baseVarName = getIdentName(oneof.getName());

        DataDstWriterNodeWrapper ret = cache.getOrDefault(baseVarName, null);
        if (ret != null) {
            return ret;
        }

        do {
            DataDstWriterNode rootNode = root.getReferNode();
            // 虚拟节点自动生成生成oneof
            if (rootNode == null) {
                break;
            }

            DataDstChildrenNode referOneof = rootNode.getChildren().getOrDefault(oneof.getName(), null);
            if (referOneof == null) {
                break;
            }

            // 配置了oneof的映射走这里,oneof和repeated冲突，只会有一个
            ret = buildWriterNodeWraper(baseVarName, referOneof.nodes.get(0), oneof, false);
        } while (false);

        // 没有配置了oneof的映射要生成一个
        if (ret == null) {
            ret = buildWriterNodeWraper(baseVarName, null, oneof, true);
        }

        root.addChidlren(ret);
        cache.put(baseVarName, ret);
        return ret;
    }

    protected LinkedList<DataDstWriterNodeWrapper> buildWriterNodeWraper(DataDstWriterNodeWrapper root,
            DataDstTypeDescriptor messageDesc) {
        DataDstWriterNode referWriterNode = root.getReferNode();

        // 只需要build一次
        if (!root.hasChidlren()) {
            HashMap<String, DataDstWriterNodeWrapper> oneofCache = null;

            for (DataDstFieldDescriptor field : messageDesc.getSortedFields()) {
                DataDstWriterNodeWrapper referOneof = null;
                // dump oneof if field refer to a oneof descriptor
                if (field.getReferOneof() != null) {
                    if (oneofCache == null) {
                        oneofCache = new HashMap<String, DataDstWriterNodeWrapper>();
                    }

                    // 非嵌套模式不支持oneof
                    referOneof = mutableOneofWriterNodeWrapper(root, oneofCache, field.getReferOneof());
                }

                String baseVarName = getIdentName(field.getName());
                // 可能是虚拟节点，直接生成一个元素即可
                if (referWriterNode == null) {
                    DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, null, field, true);
                    res.setReferOneofNode(referOneof);
                    root.addChidlren(res);
                    continue;
                }

                DataDstChildrenNode referChildren = referWriterNode.getChildren().getOrDefault(field.getName(), null);
                if (referChildren == null || referChildren.nodes == null || referChildren.nodes.isEmpty()) {
                    // 生成一个元素用于填充默认值即可
                    DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, null, field, false);
                    res.setReferOneofNode(referOneof);
                    root.addChidlren(res);
                    continue;
                }

                if (null != referOneof) {
                    referOneof.setReferField(field);
                }

                if (field.isList()) {
                    ArrayList<DataDstWriterNodeWrapper> children = new ArrayList<>();
                    children.ensureCapacity(referChildren.nodes.size());
                    for (int i = 0; i < referChildren.nodes.size(); ++i) {
                        DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, referChildren.nodes.get(i),
                                field, false);
                        res.setReferOneofNode(referOneof);
                        children.add(res);
                    }
                    root.addChidlren(children);
                } else {
                    DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, referChildren.nodes.get(0), field,
                            false);
                    res.setReferOneofNode(referOneof);
                    root.addChidlren(res);
                }
            }
        }

        LinkedList<DataDstWriterNodeWrapper> ret = new LinkedList<DataDstWriterNodeWrapper>();
        ret.add(root);
        return ret;
    }

    protected DataDstWriterNodeWrapper buildWriterNodeWraper(String varName, DataDstWriterNode referNode,
            DataDstOneofDescriptor oneofDesc, boolean isGenerated) {
        DataDstWriterNodeWrapper ret = new DataDstWriterNodeWrapper(varName, isGenerated, referNode);
        if (isGenerated && oneofDesc != null) {
            ret.setReferOneof(oneofDesc);
        }
        return ret;
    }

    protected DataDstWriterNodeWrapper buildWriterNodeWraper(String varName, DataDstWriterNode referNode,
            DataDstFieldDescriptor fieldDesc, boolean isGenerated) {
        DataDstWriterNodeWrapper ret = new DataDstWriterNodeWrapper(varName, isGenerated, referNode);
        if (isGenerated && fieldDesc != null) {
            ret.setReferField(fieldDesc);
        }
        if (ret.getTypeDescriptor().getType() != JAVA_TYPE.MESSAGE) {
            return ret;
        }

        HashMap<String, DataDstWriterNodeWrapper> oneofCache = null;

        for (DataDstFieldDescriptor field : ret.getTypeDescriptor().getSortedFields()) {
            DataDstWriterNodeWrapper referOneof = null;
            // dump oneof if field refer to a oneof descriptor
            if (field.getReferOneof() != null) {
                if (oneofCache == null) {
                    oneofCache = new HashMap<String, DataDstWriterNodeWrapper>();
                }

                // 非嵌套模式不支持oneof
                referOneof = mutableOneofWriterNodeWrapper(ret, oneofCache, field.getReferOneof());
            }

            String baseVarName = getIdentName(field.getName());
            // 可能是虚拟节点，直接生成一个元素即可
            if (referNode == null) {
                DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, null, field, true);
                res.setReferOneofNode(referOneof);
                ret.addChidlren(res);
                continue;
            }

            DataDstChildrenNode referChildren = referNode.getChildren().getOrDefault(field.getName(), null);
            if (referChildren == null || referChildren.nodes == null || referChildren.nodes.isEmpty()) {
                // 生成一个元素用于填充默认值即可
                DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, null, field, true);
                res.setReferOneofNode(referOneof);
                ret.addChidlren(res);
                continue;
            }

            if (null != referOneof) {
                referOneof.setReferField(field);
            }

            if (field.isList()) {
                ArrayList<DataDstWriterNodeWrapper> children = new ArrayList<>();
                children.ensureCapacity(referChildren.nodes.size());
                for (int i = 0; i < referChildren.nodes.size(); ++i) {
                    String childVarName = baseVarName;

                    DataDstWriterNodeWrapper res = buildWriterNodeWraper(childVarName, referChildren.nodes.get(i),
                            field, false);
                    res.setReferOneofNode(referOneof);
                    children.add(res);
                }
                ret.addChidlren(children);
            } else {
                DataDstWriterNodeWrapper res = buildWriterNodeWraper(baseVarName, referChildren.nodes.get(0), field,
                        false);
                res.setReferOneofNode(referOneof);
                ret.addChidlren(res);
            }
        }

        return ret;
    }

    /**
     * 和输出格式无关的常量转储功能
     *
     * @param data 常量数据集
     * @return 常量代码
     */
    abstract public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule)
            throws IOException, ConvException;

    /**
     * 转储常量数据
     *
     * @return 常量数据,不支持的时候返回空
     * @throws IOException
     */
    public final byte[] dumpConst(HashMap<String, Object> data) throws ConvException, IOException {
        globalCodeCache.clear();

        // 加载代码
        UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), null, null);
        DataDstWriterNode ddNode = null;

        // const完整路径都在data里了，不需要额外的包名(可能包含多个包)
        // ======================================================================================================
        LinkedList<DataDstWriterNodeWrapper> expandedDesc = new LinkedList<DataDstWriterNodeWrapper>();
        ddNode = DataDstWriterNode.create(null,
                DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.STRING), -1);
        ddNode.setFieldDescriptor(new DataDstFieldDescriptor(ddNode.getTypeDescriptor(), 1, "Name",
                DataDstWriterNode.FIELD_LABEL_TYPE.OPTIONAL, null));
        ddNode.identify = IdentifyEngine.n2i("Name", 0);

        DataDstWriterNodeWrapper constNameNode = createVirtualWriterNodeWrapper("Name", 1, JAVA_TYPE.STRING, ddNode);
        constNameNode.varName = getIdentName("Name");
        expandedDesc.add(constNameNode);

        ddNode = DataDstWriterNode.create(null,
                DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.INT), -1);
        ddNode.setFieldDescriptor(new DataDstFieldDescriptor(ddNode.getTypeDescriptor(), 2, "Value",
                DataDstWriterNode.FIELD_LABEL_TYPE.OPTIONAL, null));
        ddNode.identify = IdentifyEngine.n2i("Value", 1);

        DataDstWriterNodeWrapper constValueNode = createVirtualWriterNodeWrapper("Value", 2, JAVA_TYPE.INT, ddNode);
        constValueNode.varName = getIdentName("Value");
        expandedDesc.add(constValueNode);

        UEDataRowRule constRule = buildUEDataRowCodeRule(expandedDesc);
        constRule.helper = "helper";
        constRule.nameType = NAME_TYPE.STRING;
        // ======================================================================================================

        String constCode = dumpConstForUE(data, constRule);

        // 加载代码
        writeCodeFiles(constRule, codeInfo);

        // 写出导出文件
        writeImportSettings(codeInfo);

        // 带编码的输出
        return dumpString(constCode);
    }

    private final String getHeaderFieldUProperty() {
        if (null == headerFieldUProperty) {
            LinkedList<String> ls = new LinkedList<String>();
            if (!SchemeConf.getInstance().getUEOptions().editAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUEOptions().editAccess);
            }

            if (!SchemeConf.getInstance().getUEOptions().category.isEmpty()
                    && !SchemeConf.getInstance().getUEOptions().blueprintAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUEOptions().blueprintAccess);
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUEOptions().category));
            }
            headerFieldUProperty = String.format("    UPROPERTY(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUProperty;
    }

    private final String getHeaderFieldUFunction() {
        if (null == headerFieldUFunction) {
            LinkedList<String> ls = new LinkedList<String>();

            ls.add("BlueprintCallable");
            if (!SchemeConf.getInstance().getUEOptions().category.isEmpty()) {
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUEOptions().category));
            }
            headerFieldUFunction = String.format("    UFUNCTION(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUFunction;
    }

    private final String getDataRowKeyToNameParamsSpecify(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        // keyField can not be list, so it must has only 1 element
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.getReferNode() != null) {
            String ueTypeName = getUETypeName(nameNode.getReferField());
            if (ueTypeName.equalsIgnoreCase("FString")) {
                ueTypeName = "FName";
            }
            return String.format("%s %s", ueTypeName, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            // keyField can not be list, so it must has only 1 element
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s %s", getUETypeName(keyNode.getReferField()), keyNode.varName));
        }

        return String.join(", ", params);
    }

    private final String getDataRowKeyToNameParamsPass(UEDataRowRule rule, String prefix) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (null == prefix) {
            prefix = "";
        }

        // keyField can not be list, so it must has only 1 element
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.getReferNode() != null) {
            return String.format("%s%s", prefix, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            // keyField can not be list, so it must has only 1 element
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s%s", prefix, keyNode.varName));
        }

        return String.join(", ", params);
    }

    /**
     * @param rule
     * @return
     */
    private final String getDataRowKeyToNameExpression(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        // keyField can not be list, so it must has only 1 element
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.getReferNode() != null) {
            String ueTypeNameIdent = null;
            if (null != nameNode.getFieldExtension()) {
                ueTypeNameIdent = nameNode.getFieldExtension().mutableUE().ueTypeName;
            }
            if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                return String.format("*%s.ToString()", nameNode.varName);
            }

            switch (rule.nameType) {
                case LONG:
                    return String.format("*FString::Printf(TEXT(\"%%lld\"), static_cast<long long>(%s))",
                            nameNode.varName);
                case DOUBLE:
                    return String.format("*FString::Printf(TEXT(\"%%g\"), static_cast<double>(%s))", nameNode.varName);
                case STRING:
                    return nameNode.varName;
                default:
                    return "/** Error Key Set **/";
            }
        }

        switch (rule.nameType) {
            case LONG: {
                ArrayList<String> params = new ArrayList<String>();
                params.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    // keyField can not be list, so it must has only 1 element
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    if (keyNode.getFieldExtension().mutableUE().keyTag != 1) {
                        params.add(String.format("static_cast<long long>(%s) * %s", keyNode.varName,
                                keyNode.getFieldExtension().mutableUE().keyTag));
                    } else {
                        params.add(String.format("static_cast<long long>(%s)", keyNode.varName));
                    }
                }
                return String.format("*FString::Printf(TEXT(\"%%lld\"), %s)", String.join(" + ", params));
            }
            case DOUBLE: {
                ArrayList<String> params = new ArrayList<String>();
                params.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    // keyField can not be list, so it must has only 1 element
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    if (keyNode.getFieldExtension().mutableUE().keyTag != 1) {
                        params.add(String.format("static_cast<double>(%s) * %s", keyNode.varName,
                                keyNode.getFieldExtension().mutableUE().keyTag));
                    } else {
                        params.add(String.format("static_cast<double>(%s)", keyNode.varName));
                    }
                }
                return String.format("*FString::Printf(TEXT(\"%%g\"), %s)", String.join(" + ", params));
            }
            case STRING: {
                ArrayList<String> paramTypes = new ArrayList<String>();
                ArrayList<String> paramValues = new ArrayList<String>();
                paramTypes.ensureCapacity(rule.keyFields.size());
                paramValues.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    // keyField can not be list, so it must has only 1 element
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    String fmt = getUETypeFormat(keyNode.getJavaType());
                    paramTypes.add(fmt);

                    String ueTypeNameIdent = keyNode.getFieldExtension().mutableUE().ueTypeName;
                    if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                        paramValues.add(String.format("*%s.ToString()", keyNode.varName));
                    } else if (fmt.equals("%s")) {
                        paramValues.add("*" + keyNode.varName);
                    } else {
                        paramValues.add(keyNode.varName);
                    }
                }

                return String.format("*FString::Printf(TEXT(\"%s\"), %s)", String.join("", paramTypes),
                        String.join(", ", paramValues));
            }
            default:
                return "/** Error Key Set **/";
        }
    }

    protected String getOneofUETypeName(DataDstOneofDescriptor oneofDesc) {
        return String.format("E%sCase", getIdentName(oneofDesc.getName()));
    }

    private final void writeCodeHeaderField(FileOutputStream fout, DataDstOneofDescriptor oneofDesc, String varName,
            boolean isGenerated) throws IOException {
        if (oneofDesc == null) {
            return;
        }

        fout.write(dumpString("\r\n"));
        if (oneofDesc.mutableExtension().description != null
                && !oneofDesc.mutableExtension().description.isEmpty()) {
            for (String descLine : oneofDesc.mutableExtension().description.replace("\r\n", "\n").replace("\r", "\n")
                    .split("\n")) {
                fout.write(dumpString(String.format("    // %s\r\n", descLine)));
            }
        }

        // UE only support UENUM of uint8, so we can only use field name as case
        // selector here
        // String ueTypeName = getOneofUETypeName(oneofDesc);
        //
        // fout.write(dumpString("\r\n UENUM(BlueprintType)\r\n"));
        // fout.write(dumpString(String.format(" enum class %s: int32 {\r\n",
        // ueTypeName)));
        // fout.write(dumpString(
        // String.format(" %s_NOT_SET = 0 UMETA(DisplayName=\"Not Set\"),\r\n",
        // varName.toUpperCase())));
        //
        // for (DataDstFieldDescriptor field : oneofDesc.getSortedFields()) {
        // String subVarName = getIdentName(field.getName());
        // fout.write(dumpString(String.format(" k%s = %d UMETA(DisplayName =
        // \"%s\"),\r\n", subVarName,
        // field.getIndex(), subVarName)));
        // }
        // fout.write(dumpString(" };\r\n"));

        String ueTypeName = "FString";
        if (isGenerated) {
            fout.write(dumpString(String.format(
                    "    /** Field Type: oneof/union -> %s, Name: %s, Index: %d. This field is generated for UE Editor compatible. **/\r\n",
                    ueTypeName, varName, oneofDesc.getIndex())));
        } else {
            fout.write(dumpString(String.format("    /** Field Type: oneof/union -> %s, Name: %s, Index: %d **/\r\n",
                    ueTypeName, varName, oneofDesc.getIndex())));
        }

        fout.write(dumpString(getHeaderFieldUProperty()));
        fout.write(dumpString(String.format("    %s %s;\r\n", ueTypeName, varName)));
    }

    private final void writeCodeHeaderField(FileOutputStream fout, DataDstFieldDescriptor fieldDesc, String varName,
            boolean isGenerated) throws IOException {
        if (fieldDesc == null) {
            return;
        }

        if ((varName == null || varName.isEmpty())) {
            varName = getIdentName(fieldDesc.getName());
        }

        DataDstTypeDescriptor typeDesc = fieldDesc.getTypeDescriptor();

        fout.write(dumpString("\r\n"));
        DataDstWriterNode.JAVA_TYPE descType = DataDstWriterNode.JAVA_TYPE.STRING;
        if (null != typeDesc) {
            descType = typeDesc.getType();
            if (null != fieldDesc && fieldDesc.mutableExtension().description != null) {
                for (String descLine : fieldDesc.mutableExtension().description.replace("\r\n", "\n")
                        .replace("\r", "\n").split("\n")) {
                    fout.write(dumpString(String.format("    // %s\r\n", descLine)));
                }
            }
        }

        if (isGenerated) {
            fout.write(dumpString(String.format(
                    "    /** Field Type: %s, Name: %s, Index: %d. This field is generated for UE Editor compatible. **/\r\n",
                    descType.name(), varName, fieldDesc.getIndex())));
        } else {
            fout.write(dumpString(String.format("    /** Field Type: %s, Name: %s, Index: %d **/\r\n", descType.name(),
                    varName, fieldDesc.getIndex())));
        }

        String ueTypeName = null;
        boolean enable = true;
        switch (descType) {
            case INT:
            case LONG:
            case FLOAT:
            case DOUBLE:
            case BOOLEAN:
                break;
            case STRING: {
                if (varName.equalsIgnoreCase("Name")) {
                    ueTypeName = "FName";
                }
                break;
            }
            case BYTES: {
                if (varName.equalsIgnoreCase("Name")) {
                    ueTypeName = "FName";
                }
                fout.write(
                        dumpString(
                                String.format("    /** Bytes data will be encoded by base64 for %s */\r\n", varName)));
                break;
            }

            case MESSAGE: {
                ueTypeName = getUETypeName(typeDesc);
                break;
            }

            default:
                enable = false;
                fout.write(dumpString(String.format("    /** invalid data type %s of UE DataTable for %s */\r\n",
                        descType.name(), varName)));
                this.logErrorMessage("invalid data type %s of UE DataTable for %s, should not called here.",
                        descType.name(), varName);
                break;
        }

        if (enable) {
            if (null == ueTypeName) {
                String ueTypeNameIdent = null;
                if (null != fieldDesc) {
                    ueTypeNameIdent = fieldDesc.mutableExtension().mutableUE().ueTypeName;
                }
                if (ueTypeNameIdent == null || ueTypeNameIdent.isEmpty()) {
                    ueTypeName = getUETypeName(typeDesc);
                } else {
                    if (null != fieldDesc && fieldDesc.mutableExtension().mutableUE().ueTypeIsClass) {
                        ueTypeName = String.format("TSoftClassPtr< %s >", ueTypeNameIdent);
                    } else {
                        ueTypeName = String.format("TSoftObjectPtr< %s >", ueTypeNameIdent);
                    }
                }
            }
            fout.write(dumpString(getHeaderFieldUProperty()));

            if (fieldDesc.isMap() && typeDesc != null && typeDesc.getSortedFields().size() >= 2) {
                String keyUeTypeName = getUETypeName(typeDesc.getSortedFields().get(0).getTypeDescriptor());
                String ueTypeNameIdent = fieldDesc.mutableExtension().mutableUE().ueTypeName;
                String valueUeTypeName;
                if (ueTypeNameIdent == null || ueTypeNameIdent.isEmpty()) {
                    valueUeTypeName = getUETypeName(typeDesc.getSortedFields().get(1).getTypeDescriptor());
                } else {
                    if (null != fieldDesc && fieldDesc.mutableExtension().mutableUE().ueTypeIsClass) {
                        valueUeTypeName = String.format("TSoftClassPtr< %s >", ueTypeNameIdent);
                    } else {
                        valueUeTypeName = String.format("TSoftObjectPtr< %s >", ueTypeNameIdent);
                    }
                }

                fout.write(dumpString(
                        String.format("    TMap< %s, %s > %s;\r\n", keyUeTypeName, valueUeTypeName, varName)));
            } else if (fieldDesc.isList()) {
                fout.write(dumpString(String.format("    TArray< %s > %s;\r\n", ueTypeName, varName)));
            } else {
                fout.write(dumpString(String.format("    %s %s;\r\n", ueTypeName, varName)));
            }
        }
    }

    static private final String getUETypeName(DataDstWriterNode desc) {
        if (null == desc) {
            return "FString";
        }

        return getUETypeName(desc.getTypeDescriptor());
    }

    static private final String getUETypeName(DataDstFieldDescriptor desc) {
        if (null == desc) {
            return "FString";
        }

        return getUETypeName(desc.getTypeDescriptor());
    }

    static private final String getUETypeName(DataDstTypeDescriptor desc) {
        if (null == desc) {
            return "FString";
        }

        DataDstWriterNode.JAVA_TYPE type = desc.getType();
        switch (type) {
            case INT:
                return "int32";
            case LONG:
                return "int64";
            case FLOAT:
                return "float";
            case DOUBLE:
                return "double";
            case BOOLEAN:
                return "bool";
            case STRING:
                return "FString";
            case BYTES:
                return "FString";
            case MESSAGE:
                if (desc.getPackageName() == null || desc.getPackageName().isEmpty()) {
                    return String.format("F%s", getIdentName(desc.getMessageName()));
                } else {
                    return String.format("F%s", getIdentName(desc.getPackageName() + "_" + desc.getMessageName()));
                }
            default:
                return "";
        }
    }

    protected final String getUETypeDefault(DataDstFieldDescriptor field) {
        DataDstWriterNode.JAVA_TYPE descType = field.getType();
        String ueTypeNameIdent = field.mutableExtension().mutableUE().ueTypeName;

        if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
            return "nullptr";
        }

        switch (descType) {
            case INT:
                return "0";
            case LONG:
                return "0";
            case FLOAT:
                return "0";
            case DOUBLE:
                return "0";
            case BOOLEAN:
                return "false";
            case STRING:
                return "TEXT(\"\")";
            case BYTES:
                return "TEXT(\"\")";
            case MESSAGE:
                return "nullptr";
            default:
                return "NULL";
        }
    }

    private final void writeUETypeSetDefaultCode(FileOutputStream sourceFs, String prefix, String varName,
            DataDstOneofDescriptor oneof) throws IOException {
        // UE only support UENUM of uint8, so we can only use field name as case
        // sourceFs.write(dumpString(String.format("%s.%s =
        // decltype(%s.%s)::%s_NOT_SET;\r\n", prefix, varName,
        // prefix.trim(), varName, varName.toUpperCase())));
        sourceFs.write(dumpString(String.format("%s.%s = TEXT(\"\");\r\n", prefix, varName)));
    }

    private final void writeUETypeSetDefaultCode(FileOutputStream sourceFs, String prefix, String varName,
            DataDstFieldDescriptor field) throws IOException {
        // if (wrapper.desc != null && wrapper.desc)
        if (field.isMap()) {
            sourceFs.write(dumpString(String.format("%s.%s.Reset();\r\n", prefix, varName)));
            return;
        } else if (field.isList()) {
            sourceFs.write(dumpString(String.format("%s.%s.Reset(0);\r\n", prefix, varName)));
            return;
        }

        if (field.getType() == JAVA_TYPE.MESSAGE) {
            // 如果开启了嵌套模式，还要补全未使用的字段，因为可能被别处用到
            if (field.getTypeDescriptor().hasChildrenFields()) {
                HashSet<String> dumpedOneof = new HashSet<String>();

                for (DataDstFieldDescriptor subField : field.getTypeDescriptor().getSortedFields()) {

                    if (subField.getReferOneof() != null) {
                        String oneofVarName = getIdentName(subField.getReferOneof().getName());
                        if (!dumpedOneof.contains(oneofVarName)) {
                            writeUETypeSetDefaultCode(sourceFs, String.format("%s.%s", prefix, varName), oneofVarName,
                                    subField.getReferOneof());
                            dumpedOneof.add(oneofVarName);
                        }
                    }

                    writeUETypeSetDefaultCode(sourceFs, String.format("%s.%s", prefix, varName),
                            getIdentName(subField.getName()), subField);
                }
            }
            return;
        }

        sourceFs.write(dumpString(String.format("%s.%s = %s;\r\n", prefix, varName, getUETypeDefault(field))));
    }

    private final String getUETypeFormat(DataDstWriterNode.JAVA_TYPE type) {
        switch (type) {
            case INT:
                return "%d";
            case LONG:
                return "%lld";
            case FLOAT:
                return "%f";
            case DOUBLE:
                return "%llf";
            case BOOLEAN:
                return "%d";
            case STRING:
                return "%s";
            case BYTES:
                return "%s";
            case MESSAGE:
                return "nullptr";
            default:
                return "NULL";
        }
    }

    private final NAME_TYPE getUENameType(DataDstFieldDescriptor field) {
        if (field == null) {
            return NAME_TYPE.STRING;
        }

        if (null != field.mutableExtension()) {
            String ueTypeName = field.mutableExtension().mutableUE().ueTypeName;
            if (ueTypeName != null && !ueTypeName.isEmpty()) {
                return NAME_TYPE.STRING;
            }
        }

        switch (field.getType()) {
            case INT:
            case LONG:
            case BOOLEAN:
                return NAME_TYPE.LONG;
            case FLOAT:
            case DOUBLE:
                return NAME_TYPE.DOUBLE;
            case STRING:
            case BYTES:
            case MESSAGE:
                return NAME_TYPE.STRING;
            default:
                return NAME_TYPE.LONG;
        }
    }

    static DataDstFieldDescriptor createVirtualFieldDescriptor(String name, int index, JAVA_TYPE type) {
        return new DataDstFieldDescriptor(DataDstWriterNode.getDefaultMessageDescriptor(type), index, name,
                FIELD_LABEL_TYPE.OPTIONAL, null);
    }

    static DataDstFieldDescriptor createVirtualFieldDescriptor(String name, int index, DataDstTypeDescriptor msgDesc) {
        return new DataDstFieldDescriptor(msgDesc, index, name, FIELD_LABEL_TYPE.OPTIONAL, null);
    }

    static DataDstWriterNodeWrapper createVirtualWriterNodeWrapper(String name, int index, JAVA_TYPE type,
            DataDstWriterNode referWriterNode) {
        DataDstWriterNodeWrapper ret;
        if (type != JAVA_TYPE.MESSAGE) {
            ret = new DataDstWriterNodeWrapper(name, true, referWriterNode);
            ret.setReferField(createVirtualFieldDescriptor(name, index, type));
        } else {
            ret = new DataDstWriterNodeWrapper(name, true, referWriterNode);
            ret.setTypeDescriptor(referWriterNode.getTypeDescriptor());
        }
        return ret;
    }

    static DataDstWriterNodeWrapper createVirtualWriterNodeWrapper(String name, int index, JAVA_TYPE type) {
        DataDstWriterNodeWrapper ret = new DataDstWriterNodeWrapper(name, true, null);
        ret.setReferField(createVirtualFieldDescriptor(name, index, type));
        return ret;
    }

    private final UEDataRowRule buildUEDataRowCodeRule(LinkedList<DataDstWriterNodeWrapper> originAllFields)
            throws ConvException {
        UEDataRowRule ret = new UEDataRowRule();
        if (originAllFields.isEmpty()) {
            return ret;
        }

        ArrayList<DataDstWriterNodeWrapper> allFields = new ArrayList<DataDstWriterNodeWrapper>();

        // if originAllFields is a Message, unpack it
        if (originAllFields.size() == 1 && originAllFields.getFirst().getChildren() != null) {
            allFields.ensureCapacity(originAllFields.getFirst().getChildren().size());
            originAllFields.getFirst().getChildren().values().forEach((v) -> {
                if (!v.isEmpty()) {
                    allFields.add(v.get(0));
                }
            });
        } else {
            allFields.ensureCapacity(originAllFields.size());
            originAllFields.forEach((e) -> {
                allFields.add(e);
            });
        }

        ret = buildUEDataRowCodeRuleInner(ret, allFields);
        if (ret.keyFields != null) {
            ret.keyFields.sort((l, r) -> {
                return l.compareTo(r);
            });
        }
        if (ret.valueFields != null) {
            ret.valueFields.sort((l, r) -> {
                return l.compareTo(r);
            });
        }
        return ret;
    }

    private final UEDataRowRule buildUEDataRowCodeRuleInner(UEDataRowRule ret,
            ArrayList<DataDstWriterNodeWrapper> allFields) throws ConvException {
        if (allFields.isEmpty()) {
            return ret;
        }

        // UE 要求Key字段名必须是 Name，所以要查找Name的字段，没有的话要生成一个
        int nameIndex = -1;
        for (int i = 0; i < allFields.size(); ++i) {

            DataDstWriterNodeWrapper nw = allFields.get(i);
            if (nw.getVarName().equalsIgnoreCase("Name")) {
                nameIndex = i;
                break;
            }
        }

        // 如果字段里本来就有，就直接用原始的字段
        if (nameIndex >= 0) {
            ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
            ret.keyFields.add(allFields.get(nameIndex));
            allFields.remove(nameIndex);
            ret.valueFields = allFields;
            ret.nameType = getUENameType(ret.keyFields.get(0).getReferField());
            return ret;
        }

        // 检查 key_tag，如果找到了，就优先用 key_tag
        DataDstWriterNodeWrapper namedKey = createVirtualWriterNodeWrapper("Name", 0, JAVA_TYPE.STRING);

        ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.keyFields.add(namedKey);

        ret.valueFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.valueFields.ensureCapacity(allFields.size());

        ret.nameType = NAME_TYPE.LONG;
        for (int i = 0; i < allFields.size(); ++i) {
            DataDstWriterNodeWrapper movedField = allFields.get(i);
            DataDstFieldDescriptor fieldDesc = movedField.getReferField();
            if (null != fieldDesc && fieldDesc.mutableExtension().mutableUE().keyTag > 0) {
                if (fieldDesc.isList()) {
                    throw new ConvException(String.format("Field %s with key_tag can not be array/list/repeated",
                            fieldDesc.getTypeDescriptor().getFullName()));
                }
                ret.keyFields.add(movedField);
                switch (getUENameType(fieldDesc)) {
                    case LONG:
                        ret.nameType = NAME_TYPE.LONG;
                        break;
                    case DOUBLE:
                        if (ret.nameType == NAME_TYPE.LONG) {
                            ret.nameType = NAME_TYPE.DOUBLE;
                        }
                        break;
                    case STRING:
                        ret.nameType = NAME_TYPE.STRING;
                        break;
                    default:
                        break;
                }
            } else {
                ret.valueFields.add(movedField);
            }
        }

        // 如果没有key tag,则使用第一个非repeated\非message字段
        if (ret.keyFields.size() <= 1) {
            ret.keyFields.clear();
            ret.nameType = NAME_TYPE.STRING;
        }

        return ret;
    }

    private final void writeCodeHeaderFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        if (globalCodeWrittenCache.contains(codeInfo.header)) {
            return;
        }
        globalCodeWrittenCache.add(codeInfo.header);

        // 加载代码
        FileOutputStream headerFs = createCodeHeaderFileStream(rule, codeInfo);

        HashSet<String> dumpedFields = new HashSet<String>();
        // The key field of 0 is FName Name
        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper descWraper = rule.keyFields.get(i);
            DataDstFieldDescriptor field = descWraper.getReferField();
            if (null == field) {
                continue;
            }

            dumpedFields.add(descWraper.varName);

            writeCodeHeaderField(headerFs, descWraper.getReferField(), descWraper.varName, descWraper.isGenerated);
        }

        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper descWraper = rule.valueFields.get(i);
            dumpedFields.add(descWraper.varName);

            // oneof 处理
            if (descWraper.getReferOneof() != null) {
                writeCodeHeaderField(headerFs, descWraper.getReferOneof(), descWraper.varName,
                        descWraper.isGenerated);
                dumpedFields.add(descWraper.varName);
                continue;
            }

            writeCodeHeaderField(headerFs, descWraper.getReferField(), descWraper.varName, descWraper.isGenerated);
        }

        // 还要补全未使用的字段
        if (null != codeInfo.writerNodeWrapper) {
            for (DataDstFieldDescriptor field : codeInfo.writerNodeWrapper.getTypeDescriptor().getSortedFields()) {

                // Write oneof
                if (field.getReferOneof() != null) {
                    String oneofVarName = getIdentName(field.getReferOneof().getName());
                    if (!dumpedFields.contains(oneofVarName)) {
                        writeCodeHeaderField(headerFs, field.getReferOneof(), oneofVarName, false);
                        dumpedFields.add(oneofVarName);
                    }
                }

                String varName = getIdentName(field.getName());
                if (dumpedFields.contains(varName)) {
                    continue;
                }
                dumpedFields.add(varName);

                writeCodeHeaderField(headerFs, field, varName, false);
            }
        }

        headerFs.write(dumpString(codeHeaderSuffix));

        if (rule.helper == null || rule.helper.isEmpty()) {
            headerFs.close();
            return;
        }

        boolean enableDataTable = true;
        if (rule.keyFields.isEmpty()) {
            enableDataTable = false;
        }
        if (null != codeInfo.writerNodeWrapper) {
            DataDstMessageExtUE ueExt = codeInfo.writerNodeWrapper.getMessageExtension().mutableUE();
            if (ueExt.notDataTable) {
                enableDataTable = false;
            }
        }

        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        // 辅助代码类定义
        String helperClazzName = getIdentName(codeInfo.baseName + "_" + rule.helper);
        headerFs.write(dumpString("UCLASS(Blueprintable, BlueprintType)\r\n"));
        headerFs.write(dumpString(String.format("class U%s : public UObject\r\n", helperClazzName)));
        headerFs.write(dumpString("{\r\n"));
        headerFs.write(dumpString("    GENERATED_BODY()\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("public:\r\n"));
        headerFs.write(dumpString(String.format("    U%s();\r\n", helperClazzName)));
        headerFs.write(dumpString("\r\n"));

        if (enableDataTable) {
            headerFs.write(dumpString("    void OnReload();\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(
                    "    void SetLoader(TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > NewLoader);\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString("    void InitializeDefaultLoader() const;\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString("    void DisableDefaultLoader();\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString("    const TCHAR* GetObjectPath() const;\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(
                    String.format("    static FName GetRowName(%s);\r\n", getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    FName GetDataRowName(%s) const;\r\n", getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    FName GetTableRowName(const %s& TableRow) const;\r\n", codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    const %s& GetDataRowByName(const FName& Name, bool& IsValid) const;\r\n",
                            codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(String.format("    const %s& GetDataRowByKey(%s, bool& IsValid) const;\r\n",
                    codeInfo.clazzName, getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(String.format(
                    "    bool ForeachRow(TFunctionRef<void (const FName& Key, const %s& Value)> Predicate) const;\r\n",
                    codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString("    UDataTable* GetRawDataTable(bool& IsValid) const;\r\n"));
            headerFs.write(dumpString("\r\n"));
        }

        headerFs.write(dumpString(String.format("    static void ClearRow(%s& TableRow);\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    void ClearDataRow(%s& TableRow) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("private:\r\n"));
        if (enableDataTable) {
            headerFs.write(dumpString("    TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > Loader;\r\n"));
            headerFs.write(dumpString("    UDataTable* DataTable;\r\n"));
            headerFs.write(dumpString("    bool EnableDefaultLoader;\r\n"));
        }
        headerFs.write(dumpString(String.format("    %s Empty;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("};\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.close();
    }

    private final void writeCodeSourceFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        if (globalCodeWrittenCache.contains(codeInfo.source)) {
            return;
        }
        globalCodeWrittenCache.add(codeInfo.source);

        FileOutputStream sourceFs = createCodeSourceFileStream(rule, codeInfo);

        if (rule.helper == null || rule.helper.isEmpty()) {
            sourceFs.close();
            return;
        }

        String varIsValidName = "IsValid";
        boolean varIsValidCheck = true;
        boolean enableDataTable = true;
        boolean enableDefaultLoader = SchemeConf.getInstance().getUEOptions().codeOutputEnableDefaultLoader;
        if (rule.keyFields.isEmpty()) {
            enableDataTable = false;
        }
        if (null != codeInfo.writerNodeWrapper) {
            DataDstMessageExtUE ueExt = codeInfo.writerNodeWrapper.getMessageExtension().mutableUE();
            if (ueExt.notDataTable) {
                enableDataTable = false;
            }
            if (ueExt.enableDefaultLoader != null) {
                enableDefaultLoader = ueExt.enableDefaultLoader;
            }
        }

        while (varIsValidCheck) {
            varIsValidCheck = false;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                if (rule.keyFields.get(i).varName.equalsIgnoreCase(varIsValidName)) {
                    varIsValidName = varIsValidName + "DTR";
                    varIsValidCheck = true;
                }
            }
        }

        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        // 辅助代码类实现
        String helperClazzName = getIdentName(codeInfo.baseName + "_" + rule.helper);
        String helperDestination;
        if (codeInfo.destinationPath.isEmpty()) {
            helperDestination = codeInfo.baseName;
        } else {
            File filePath = new File(codeInfo.outputFile);
            String fileBaseName = filePath.getName();
            int suffixSplit = fileBaseName.lastIndexOf('.');
            if (suffixSplit > 0) {
                fileBaseName = fileBaseName.substring(0, suffixSplit);
            }
            helperDestination = String.format("%s/%s", codeInfo.destinationPath, fileBaseName);
        }

        // constructor
        sourceFs.write(dumpString(String.format("U%s::U%s() : Super()\r\n", helperClazzName, helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        // 初始化Empty
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(this->Empty);\r\n", helperClazzName)));
        if (enableDataTable) {
            sourceFs.write(dumpString("    this->DataTable = nullptr;\r\n"));
            if (enableDefaultLoader) {
                sourceFs.write(dumpString("    this->EnableDefaultLoader = true;\r\n"));
                sourceFs.write(dumpString("    this->InitializeDefaultLoader();\r\n"));
            } else {
                sourceFs.write(dumpString("    this->EnableDefaultLoader = false;\r\n"));
            }
        }
        sourceFs.write(dumpString("}\r\n\r\n"));

        if (enableDataTable) {
            // OnReload()
            sourceFs.write(dumpString(String.format("void U%s::OnReload()\r\n", helperClazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    // TODO Rebuild Index\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // void SetLoader(TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> >
            // NewLoader);
            sourceFs.write(dumpString(String.format(
                    "void U%s::SetLoader(TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > NewLoader)\r\n",
                    helperClazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    this->Loader = NewLoader;\r\n"));
            // 初始化事件监听
            sourceFs.write(dumpString("    if (this->Loader && this->Loader->Succeeded())\r\n"));
            sourceFs.write(dumpString("    {\r\n"));
            sourceFs.write(dumpString("        this->DataTable = this->Loader->Object;\r\n"));
            sourceFs.write(dumpString(
                    String.format("        this->DataTable->OnDataTableChanged().AddUObject(this, &U%s::OnReload);\r\n",
                            helperClazzName)));
            sourceFs.write(dumpString("        OnReload();\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("    else\r\n"));
            sourceFs.write(dumpString("    {\r\n"));
            sourceFs.write(dumpString("        this->DataTable = nullptr;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // void InitializeDefaultLoader() const;
            sourceFs.write(dumpString(String.format("void U%s::InitializeDefaultLoader() const\r\n", helperClazzName,
                    codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    if (!this->EnableDefaultLoader) {\r\n"));
            sourceFs.write(dumpString("        return;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString(
                    String.format("    const_cast<U%s*>(this)->EnableDefaultLoader = false;\r\n", helperClazzName)));
            sourceFs.write(dumpString(String.format(
                    "    const_cast<U%s*>(this)->SetLoader(MakeShareable(new ConstructorHelpers::FObjectFinder<UDataTable>(GetObjectPath())));\r\n",
                    helperClazzName)));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // void DisableDefaultLoader();
            sourceFs.write(dumpString(
                    String.format("void U%s::DisableDefaultLoader()\r\n", helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    this->EnableDefaultLoader = false;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // void GetObjectPath();
            sourceFs.write(dumpString(
                    String.format("const TCHAR* U%s::GetObjectPath() const\r\n", helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(
                    dumpString(String.format("    return TEXT(\"DataTable'/Game/%s'\");\r\n", helperDestination)));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetRowName(...)
            sourceFs.write(dumpString(String.format("FName U%s::GetRowName(%s)\r\n", helperClazzName,
                    getDataRowKeyToNameParamsSpecify(rule))));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return %s;\r\n", getDataRowKeyToNameExpression(rule))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetDataRowName(...)
            sourceFs.write(dumpString(String.format("FName U%s::GetDataRowName(%s) const\r\n", helperClazzName,
                    getDataRowKeyToNameParamsSpecify(rule))));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return U%s::GetRowName(%s);\r\n", helperClazzName,
                    getDataRowKeyToNameParamsPass(rule, ""))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetTableRowName(const T& TableRow)
            sourceFs.write(dumpString(String.format("FName U%s::GetTableRowName(const %s& TableRow) const\r\n",
                    helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return GetDataRowName(%s);\r\n",
                    getDataRowKeyToNameParamsPass(rule, "TableRow."))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetTableRowName(const T& TableRow)
            sourceFs.write(
                    dumpString(String.format("const %s& U%s::GetDataRowByName(const FName& Name, bool& %s) const\r\n",
                            codeInfo.clazzName, helperClazzName, varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return this->Empty;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString("    FString Context;\r\n"));
            sourceFs.write(
                    dumpString(String.format("    %s* LookupRow = DataTable->FindRow<%s>(Name, Context, false);\r\n",
                            codeInfo.clazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("    if (!LookupRow) {\r\n"));
            sourceFs.write(dumpString("        return this->Empty;\r\n"));
            sourceFs.write(dumpString("    };\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    return *LookupRow;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetDataRowByKey(..., bool& IsValid)
            sourceFs.write(dumpString(String.format("const %s& U%s::GetDataRowByKey(%s, bool& %s) const\r\n",
                    codeInfo.clazzName, helperClazzName, getDataRowKeyToNameParamsSpecify(rule), varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return GetDataRowByName(GetDataRowName(%s), %s);\r\n",
                    getDataRowKeyToNameParamsPass(rule, ""), varIsValidName)));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // ForeachRow(TFunctionRef<void (const FName& Key, const T& Value)> Predicate)
            sourceFs.write(dumpString(String.format(
                    "bool U%s::ForeachRow(TFunctionRef<void (const FName& Key, const %s& Value)> Predicate) const\r\n",
                    helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return false;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString("    FString Context;\r\n"));
            sourceFs.write(dumpString("    this->DataTable->ForeachRow(Context, Predicate);\r\n"));
            sourceFs.write(dumpString("    return true;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetRawDataTable(bool& IsValid)
            sourceFs.write(dumpString(String.format("UDataTable* U%s::GetRawDataTable(bool& %s) const\r\n",
                    helperClazzName, varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return NULL;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    return this->DataTable;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));
        }

        // static void ClearDataRow(const %s& TableRow);
        sourceFs.write(
                dumpString(String.format("void U%s::ClearRow(%s& TableRow)\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        HashSet<String> dumpedFields = new HashSet<String>();

        // The key field of 0 is FName Name
        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
            if (wrapper == null) {
                continue;
            }

            DataDstFieldDescriptor field = wrapper.getReferField();
            if (null == field) {
                continue;
            }
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper.varName, field);
            if (null != dumpedFields) {
                dumpedFields.add(wrapper.varName);
            }
        }

        HashSet<String> dumpedOneof = new HashSet<String>();
        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.valueFields.get(i);
            if (wrapper == null) {
                continue;
            }

            if (wrapper.getReferOneof() != null) {
                writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper.varName, wrapper.getReferOneof());
                dumpedOneof.add(wrapper.varName);
                continue;
            }

            DataDstFieldDescriptor field = wrapper.getReferField();
            if (null == field) {
                continue;
            }
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper.varName, field);
            if (null != dumpedFields) {
                dumpedFields.add(wrapper.varName);
            }
        }

        // 如果开启了嵌套模式，还要补全未使用的字段，因为可能被别处用到
        if (null != codeInfo.writerNodeWrapper) {
            for (DataDstFieldDescriptor field : codeInfo.writerNodeWrapper.getTypeDescriptor().getSortedFields()) {
                // Write oneof
                if (field.getReferOneof() != null) {
                    String oneofVarName = getIdentName(field.getReferOneof().getName());
                    if (!dumpedOneof.contains(oneofVarName)) {
                        writeUETypeSetDefaultCode(sourceFs, "    TableRow", oneofVarName, field.getReferOneof());
                        dumpedOneof.add(oneofVarName);
                    }
                }

                String varName = getIdentName(field.getName());
                if (dumpedFields != null) {
                    if (dumpedFields.contains(varName)) {
                        continue;
                    }
                    dumpedFields.add(varName);
                }

                writeUETypeSetDefaultCode(sourceFs, "    TableRow", varName, field);
            }
        }
        sourceFs.write(dumpString("}\r\n\r\n"));

        // void ClearDataRow(const %s& TableRow) const;
        sourceFs.write(dumpString(
                String.format("void U%s::ClearDataRow(%s& TableRow) const\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(TableRow);\r\n", helperClazzName)));
        sourceFs.write(dumpString("}\r\n\r\n"));

        sourceFs.close();
    }
}
