package org.xresloader.core.data.dst;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.QuoteMode;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstOneofDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstTypeDescriptor;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.scheme.SchemeConf;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.*;

/**
 * Created by owentou on 2019/04/08.
 */
public class DataDstUECsv extends DataDstUEBase {
    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue csv";
    }

    public void appendCommonHeader(CSVPrinter sp) throws IOException {
        sp.printComment("This file is generated by xresloader, please don't edit it.");
    }

    private class UEBuildObject {
        StringBuffer sb = null;
        CSVPrinter csv = null;
        ArrayList<DataDstWriterNodeWrapper> headerNodes = null;
        ArrayList<DataDstWriterNodeWrapper> headerAutocomplete = null;
        boolean hasPrintHeader = false;
    }

    @Override
    protected Object buildForUEOnInit() throws IOException {
        UEBuildObject ret = new UEBuildObject();
        ret.sb = new StringBuffer();
        ret.csv = new CSVPrinter(ret.sb, CSVFormat.INFORMIX_UNLOAD_CSV.builder().setQuoteMode(QuoteMode.ALL).build());

        appendCommonHeader(ret.csv);
        ret.csv.printComment(String.format("%s=%s", "xres_ver", ProgramOptions.getInstance().getVersion()));
        ret.csv.printComment(String.format("%s=%s", "data_ver", ProgramOptions.getInstance().getDataVersion()));
        ret.csv.printComment(String.format("%s=%d", "count", DataSrcImpl.getOurInstance().getRecordNumber()));
        ret.csv.printComment(String.format("%s=%s", "hash_code", "no hash code"));

        return ret;
    }

    @Override
    protected byte[] buildForUEOnFinal(Object buildObj) throws ConvException {
        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return ((UEBuildObject) buildObj).sb.toString().getBytes();

        return ((UEBuildObject) buildObj).sb.toString().getBytes(Charset.forName(encoding));
    }

    @Override
    protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<DataDstWriterNodeWrapper> rowData,
            UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {
        if (((UEBuildObject) buildObj).hasPrintHeader) {
            return;
        }

        HashSet<String> dumpedFields = new HashSet<String>();
        ArrayList<String> finalRowData = new ArrayList<String>();
        ArrayList<DataDstWriterNodeWrapper> headerAutocomplete = new ArrayList<>();

        ((UEBuildObject) buildObj).hasPrintHeader = true;
        ((UEBuildObject) buildObj).headerNodes = rowData;
        ((UEBuildObject) buildObj).headerAutocomplete = headerAutocomplete;

        if (codeInfo.writerNodeWrapper != null && codeInfo.writerNodeWrapper.hasChidlren()) {
            finalRowData.ensureCapacity(rowData.size() + 1); // 1 for additional Name
        }
        // Add a empty column for "Row Name"
        finalRowData.add("---");
        for (DataDstWriterNodeWrapper keyName : rowData) {
            dumpedFields.add(keyName.getVarName());
            finalRowData.add(keyName.getVarName());
        }

        // 需要补全空字段 - header
        if (codeInfo.writerNodeWrapper != null && null != codeInfo.writerNodeWrapper.getTypeDescriptor()) {
            // 字段补全
            for (DataDstFieldDescriptor field : codeInfo.writerNodeWrapper.getTypeDescriptor().getSortedFields()) {
                String varName = getIdentName(field.getName());

                // Write oneof
                if (field.getReferOneof() != null) {
                    String oneofVarName = getIdentName(field.getReferOneof().getName());

                    if (!dumpedFields.contains(oneofVarName)) {
                        dumpedFields.add(oneofVarName);
                        finalRowData.add(oneofVarName);

                        DataDstWriterNodeWrapper virtualNode = new DataDstWriterNodeWrapper(oneofVarName, true, null);
                        virtualNode.setReferOneof(field.getReferOneof());
                        headerAutocomplete.add(virtualNode);
                    }
                }

                if (dumpedFields.contains(varName)) {
                    continue;
                }
                dumpedFields.add(varName);
                finalRowData.add(varName);
                DataDstWriterNodeWrapper virtualNode = new DataDstWriterNodeWrapper(varName, true, null);
                virtualNode.setReferField(field);
                headerAutocomplete.add(virtualNode);
            }
        }

        ((UEBuildObject) buildObj).csv.printRecord(finalRowData);
    }

    @Override
    protected void buildForUEOnPrintRecord(Object buildObj, HashMap<String, Object> rowData,
            UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {

        UEBuildObject bobj = ((UEBuildObject) buildObj);

        // 顺序约定:(必须和上面输出header保持一样的顺序)
        // 1. key
        // 2. value(包含oneof)
        // 3. 补全空字段(提取自
        // codeInfo.writerNodeWrapper.getTypeDescriptor().getSortedFields())

        HashSet<String> dumpedFields = new HashSet<String>();
        ArrayList<String> finalRowData = new ArrayList<String>();
        finalRowData.ensureCapacity(
                bobj.headerNodes.size() + bobj.headerAutocomplete.size() + 1);

        // 额外写出一份 --- 的Key
        if (!bobj.headerNodes.isEmpty()) {
            StringBuffer fieldSb = new StringBuffer();
            dumpField(fieldSb, new HashSet<String>(), bobj.headerNodes.get(0), rowData, true);
            finalRowData.add(fieldSb.toString());
        }

        for (DataDstWriterNodeWrapper headerNode : bobj.headerNodes) {
            if (dumpedFields.contains(headerNode.getVarName())) {
                continue;
            }

            StringBuffer fieldSb = new StringBuffer();
            dumpField(fieldSb, dumpedFields, headerNode, rowData, true);

            finalRowData.add(fieldSb.toString());
        }

        for (DataDstWriterNodeWrapper virtualNode : bobj.headerAutocomplete) {
            String varName = virtualNode.getVarName();
            if (dumpedFields.contains(varName)) {
                continue;
            }
            dumpedFields.add(varName);

            StringBuffer fieldSb = new StringBuffer();

            if (virtualNode.getReferOneof() != null) {
                pickValueFieldCsvDefaultImpl(fieldSb, virtualNode.getReferOneof(), false);
            } else {
                pickValueFieldCsvDefaultImpl(fieldSb, virtualNode.getReferField(), false, true);
            }

            finalRowData.add(fieldSb.toString());
        }

        ((UEBuildObject) buildObj).csv.printRecord(finalRowData);
    }

    @Override
    public DataDstWriterNode compile() {
        this.logErrorMessage("UE-CSV can not be protocol description.");
        return null;
    }

    @SuppressWarnings("unchecked")
    private void writeConstData(CSVPrinter sp, Object data, String prefix) throws IOException {
        // null
        if (null == data) {
            sp.printRecord(prefix, "");
            return;
        }

        // 数字
        // 枚举值已被转为Java Long，会在这里执行
        if (data instanceof Number) {
            sp.printRecord(prefix, data);
            return;
        }

        // 布尔
        if (data instanceof Boolean) {
            sp.printRecord(prefix, ((Boolean) data) ? "True" : "False");
            return;
        }

        // 字符串&二进制
        if (data instanceof String) {
            sp.printRecord(prefix, data);
            return;
        }

        // 列表
        if (data instanceof List) {
            List<Object> ls = (List<Object>) data;
            for (int i = 0; i < ls.size(); ++i) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, ls.get(i), String.format("%d", i));
                } else {
                    writeConstData(sp, ls.get(i), String.format("%s.%d", prefix, i));
                }
            }
            return;
        }

        // Hashmap
        if (data instanceof Map) {
            Map<String, Object> mp = (Map<String, Object>) data;
            ArrayList<Map.Entry<String, Object>> sorted_array = new ArrayList<Map.Entry<String, Object>>();
            sorted_array.ensureCapacity(mp.size());
            sorted_array.addAll(mp.entrySet());
            sorted_array.sort((l, r) -> {
                return l.getKey().compareTo(r.getKey());
            });

            for (Map.Entry<String, Object> item : sorted_array) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, item.getValue(), String.format("%s", item.getKey()));
                } else {
                    writeConstData(sp, item.getValue(), String.format("%s.%s", prefix, item.getKey()));
                }
            }
            return;
        }

        sp.printRecord(prefix, data.toString());
    }

    /**
     * 和输出格式无关的常量转储功能
     * 
     * @param data 常量数据集
     * @return 常量代码
     */
    @Override
    public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException, ConvException {
        StringBuffer sb = new StringBuffer();
        CSVPrinter csv = new CSVPrinter(sb,
                CSVFormat.EXCEL.builder().setHeader(getIdentName("Name"), getIdentName("Value")).build());

        appendCommonHeader(csv);
        writeConstData(csv, data, "");

        return sb.toString();
    }

    private void dumpMessage(StringBuffer sb, DataDstWriterNodeWrapper descWraper,
            HashMap<?, ?> dataSet) {

        sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);

        // 仅需要数据结构，提取一个节点就行了，剩下的走dataSet
        ArrayList<DataDstWriterNodeWrapper> children = new ArrayList<>();
        children.ensureCapacity(descWraper.getChildren().size());
        descWraper.getChildren().values().forEach((ea) -> {
            if (!ea.isEmpty()) {
                children.add(ea.get(0));
            }
        });

        children.sort((l, r) -> {
            return l.compareTo(r);
        });

        HashSet<String> dumpedFields = new HashSet<>();
        boolean isFirst = true;
        for (DataDstWriterNodeWrapper child : children) {
            isFirst = tryWriteSeprator(sb, isFirst);
            dumpField(sb, dumpedFields, child, dataSet, false);
        }

        // 补全缺失字段
        for (DataDstWriterNodeWrapper child : children) {
            if (!dumpedFields.contains(child.getVarName())) {
                isFirst = tryWriteSeprator(sb, isFirst);

                // Key
                sb.append(child.getVarName());
                sb.append("=");
                // Value
                if (child.getReferOneof() != null) {
                    pickValueFieldCsvDefaultImpl(sb, child.getReferOneof(), true);
                } else {
                    pickValueFieldCsvDefaultImpl(sb, child.getReferField(), true, false);
                }
            }
        }

        sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
    }

    private void dumpFieldValue(StringBuffer sb, DataDstWriterNodeWrapper descWraper, Object data, boolean isTopLevel) {
        if (data instanceof List<?>) {
            sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);
            boolean isFirst = true;
            for (Object val : (List<?>) data) {
                isFirst = tryWriteSeprator(sb, isFirst);
                dumpFieldValue(sb, descWraper, val, false);
            }
            sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
        } else if (data instanceof SpecialInnerHashMap<?, ?>) {
            ArrayList<DataDstWriterNodeWrapper> valueDesc = descWraper.getMapValueField();

            sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);
            if (!valueDesc.isEmpty()) {
                boolean isFirst = true;
                ArrayList<Map.Entry<?, ?>> sorted_array = new ArrayList<Map.Entry<?, ?>>();
                sorted_array.ensureCapacity(((SpecialInnerHashMap<?, ?>) data).size());
                sorted_array.addAll(((SpecialInnerHashMap<?, ?>) data).entrySet());
                sorted_array.sort((l, r) -> {
                    if (l.getKey() instanceof Integer && r.getKey() instanceof Integer) {
                        return ((Integer) l.getKey()).compareTo((Integer) r.getKey());
                    } else if (l.getKey() instanceof Long && r.getKey() instanceof Long) {
                        return ((Long) l.getKey()).compareTo((Long) r.getKey());
                    } else {
                        return l.getKey().toString().compareTo(r.getKey().toString());
                    }
                });

                for (Map.Entry<?, ?> subval : sorted_array) {
                    isFirst = tryWriteSeprator(sb, isFirst);
                    sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);
                    sb.append("\"");
                    sb.append(subval.getKey().toString());
                    sb.append("\",");
                    dumpFieldValue(sb, valueDesc.get(0), subval.getValue(), false);
                    sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
                }
            }

            sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
        } else if (data instanceof HashMap<?, ?>) {
            dumpMessage(sb, descWraper, (HashMap<?, ?>) data);
        } else {
            if (data instanceof Number) {
                sb.append(data);
            } else if (data instanceof Boolean) {
                if ((Boolean) data) {
                    sb.append("True");
                } else {
                    sb.append("False");
                }
            } else if (data instanceof String) {
                if (!isTopLevel) {
                    sb.append("\"");
                }
                sb.append(((String) data).replaceAll("\"", "\"\""));
                if (!isTopLevel) {
                    sb.append("\"");
                }
            } else if (data instanceof com.google.protobuf.ByteString) {
                if (!isTopLevel) {
                    sb.append("\"");
                }
                sb.append(((com.google.protobuf.ByteString) data).toString().replaceAll("\"", "\"\""));
                if (!isTopLevel) {
                    sb.append("\"");
                }
            } else if (data instanceof byte[]) {
                if (!isTopLevel) {
                    sb.append("\"");
                }
                sb.append(((byte[]) data).toString().replaceAll("\"", "\"\""));
                if (!isTopLevel) {
                    sb.append("\"");
                }
            } else {
                if (descWraper.getReferOneof() != null) {
                    pickValueFieldCsvDefaultImpl(sb, descWraper.getReferOneof(), !isTopLevel);
                } else {
                    pickValueFieldCsvDefaultImpl(sb, descWraper.getReferField(), true, isTopLevel);
                }
            }
        }
    }

    private void dumpField(StringBuffer sb, HashSet<String> dumpedFields, DataDstWriterNodeWrapper descWraper,
            HashMap<?, ?> dataSet, boolean isTopLevel) {
        if (dumpedFields.contains(descWraper.getVarName())) {
            return;
        }

        dumpedFields.add(descWraper.getVarName());
        if (!isTopLevel) {
            sb.append(descWraper.getVarName());
            sb.append("=");
        }

        Object val = pickJavaFieldValue(dataSet, descWraper);
        if (val == null) {
            if (descWraper.getReferOneof() != null) {
                pickValueFieldCsvDefaultImpl(sb, descWraper.getReferOneof(), !isTopLevel);
            } else {
                pickValueFieldCsvDefaultImpl(sb, descWraper.getReferField(), true, isTopLevel);
            }
            return;
        }

        dumpFieldValue(sb, descWraper, val, isTopLevel);
    }

    static private boolean tryWriteSeprator(StringBuffer sb, boolean isFirst) {
        if (isFirst) {
            return false;
        }

        sb.append(",");
        return false;
    }

    protected boolean pickValueMessageCsvDefaultImpl(StringBuffer sb, DataDstTypeDescriptor fd, boolean fillEmpty,
            boolean isTopLevel) {
        if (fd == null) {
            return false;
        }

        switch (fd.getType()) {
            case INT:
            case LONG:
            case FLOAT:
            case DOUBLE: {
                sb.append("0");
                break;
            }
            case BOOLEAN: {
                sb.append("False");
                break;
            }
            case STRING:
            case BYTES: {
                if (fillEmpty && !isTopLevel) {
                    sb.append("\"\"");
                } else {
                    return false;
                }

                break;
            }
            case MESSAGE: {
                sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);

                HashSet<String> dumpedOneof = new HashSet<String>();
                boolean isFirstField = true;
                for (DataDstFieldDescriptor subField : fd.getSortedFields()) {
                    if (isFirstField) {
                        isFirstField = false;
                    } else {
                        sb.append(",");
                    }

                    // 需要dump一次oneof字段
                    if (null != subField.getReferOneof()) {
                        String oneofVarName = getIdentName(subField.getReferOneof().getName());
                        if (!dumpedOneof.contains(oneofVarName)) {
                            dumpedOneof.add(oneofVarName);
                            sb.append(oneofVarName);
                            sb.append("=");
                            pickValueFieldCsvDefaultImpl(sb, subField.getReferOneof(), true);
                            sb.append(",");
                        }
                    }

                    sb.append(getIdentName(subField.getName()));
                    sb.append("=");
                    if (subField.isList()) { // empty map is just like empty list
                        sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);
                        sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
                    } else if (subField.getType() == DataDstWriterNode.JAVA_TYPE.STRING
                            || subField.getType() == DataDstWriterNode.JAVA_TYPE.BYTES) {
                        sb.append("\"\"");
                    } else {
                        // 嵌套默认值总是要输出空值
                        pickValueFieldCsvDefaultImpl(sb, subField, true, false);
                    }
                }

                sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
                break;
            }
            default:
                return false;
        }

        return true;
    }

    protected boolean pickValueFieldCsvDefaultImpl(StringBuffer sb, DataDstFieldDescriptor fd, boolean fillEmpty,
            boolean isTopLevel) {
        if (fd.isList()) { // empty map is just like empty list
            if (fillEmpty) {
                sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectBegin);
                sb.append(SchemeConf.getInstance().getUEOptions().codeOutputCsvObjectEnd);
                return true;
            } else {
                return false;
            }
        }

        return pickValueMessageCsvDefaultImpl(sb, fd.getTypeDescriptor(), fillEmpty, isTopLevel);
    }

    protected boolean pickValueFieldCsvDefaultImpl(StringBuffer sb, DataDstOneofDescriptor fd, boolean needQuote) {
        if (needQuote) {
            sb.append("\"\"");
            return true;
        } else {
            return false;
        }
    }
}
